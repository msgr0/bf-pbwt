---
title: "on the positional BWT" 
author: "Mattia S."
output-dir: docs
bibliography: references.bib
bibliographystyle: unsrt
csl: diabetologia.csl
format:
  html
---

# bf-pbwt results

|BLIM timing(s)|chr10(18gb)|chr21(4.7gb)|chr22(4.8)|
|---|---|---|---|---|
|2bfpbwt-bm on master| 690.53 | 110.47 | 116.99 |
|2bfpbwt on (71a045a) | 294.98 | 74.48 | 75.54 |
|2bfpbwt-bm on (hotfix) | 753.71 | 108.56 | 113.40 |

|BLIM ram (GiB) |chr10(18gb)|chr21(4.7gb)|chr22(4.8)|
|---|---|---|---|---|
|2bfpbwt-bm on master| 250| 82 | 84 |
|2bfpbwt on (71a045a) | 158 | 43 | 44 |
|2bfpbwt-bm on (hotfix) | 244 | 82 | 84 |

# REVIEW

## Durbin's Original PBWT [https://github.com/richarddurbin/pbwt, @durbinEfficientHaplotypeMatching2014](https://github.com/richarddurbin/pbwt)

**Input**:

a binary matrix $X$, of $m$ rows and $n$ columns.
$(\Sigma = \{0, 1\})$, where $x_i$ are haplotype sequences; $0\leq i < m$ and $x_i \in \Sigma^n$


**Output**:

for each column $k$ in $0\leq k < n$ we represent:

- a *prefix* array $A_k$ that stores the permutation of the rows in $X$ according to the co-lex ordering of the subsequences of $X$ from $0$ to $k$;

- $Y_k$, the entire matrix $X$ with $x_i$ permuted according to $A_k$ (not computed)

- an array $y^k = Y_k[k+1]$ containg the permutation of the input $X$'s next column, according to the row permutation in $A_k$.
  This is computed on-the-fly (and not stored!) reading $X[k+1]$ by the permutation stored in $A_k$.

- a *divergence* array $D_k$ that stores the length of the $LCP^{-1}$ between each pair $(y_i[0,k], y_{i-1}[0,k])$

**The catch** 

> $A_k$ and $D_k$ can be computed by $A_{k-1}$ and $D_{k-1}$ linearly in space/time $O(m)$[@durbinEfficientHaplotypeMatching2014].

- The overall computation time of the $\texttt{PBWT}$ (composed of arrays $A_k$ and $D_k$ for each $k$ ...
is $O(n\cdot m)$.

- Moreover, if we keep only $\texttt{PBWT}_{k}$ to compute the next $\texttt{PBWT}_{k+1}$, we can do so in $O(m)$ space,
performing some other computation on each $\texttt{PBWT}$ before it is discarded.

## PBWT Use:

1. Indexing + Querying of *Set Maximal Exact Matches* and/or *L-long matches*, computing so-called *matching statistics*
   + SMEMs: match a pattern $P$ against $X$, retrive the longest matches of $P[0,k]$ subsequences in co-lex ordering.


1. Computing internal all-vs-all matches longer than $L$ and/or Maximal Perfect Haplotype Blocks (MPHB) 
 
#### Tools
+ Durbin's pbwt [@durbinEfficientHaplotypeMatching2014] [git](https://github.com/richarddurbin/pbwt)
  + First Definition of PBWT
  + Reads VCF/BCF or .macs simulated data
  + On-line computation
  + Computes internal **L-long** matches, internal **SMEMs**, external (query) **SMEMs**.

+ mu-pbwt [@cozziPBWTLightweightRindexing2023] [git](https://github.com/dlcgold/muPBWT)
  + Run-Length encoding of the PBWT
  + reads VCF/BCF
  + indexes and queries of a pattern against the VCF 
  + computes external **SMEMs** and **L-long matches**

+ d-pbwt [@sanaullahDPBWTDynamicPositional2021] [git](http://genome.ucf.edu/d-PBWT/)
  + Dynamic pbwt to dynamically insert/delete reads
  + reads VCF
  + indexes and queries of patterns against Panel,
  + computes external **L-long matches**

+ dynamic-mu-pbwt [@shakyaDynamicMPBWTDynamic2025] [git](https://github.com/ucfcbb/Dynamic-mu-PBWT)
  + dynamic + mu PBWT
  + reads VCF
  + indexes and queries of patterns against Panel,
  + computes external **SMEMs** and **L-long matches** 


+ PBWT-Query [@naseriEfficientHaplotypeMatching2019] [git](genome.ucf.edu/pbwt-query)
  + Code is unaccesible, may read VCF
  + Uses "Leap Arrays" to jump from differente $D$ values in $y^k$
  + Notes: several version of the algorithms are proposed
    + **PBWT-Query** memory extensive, panel in memory 
    + **L-PBWT-Query** memory mapped, panel lazy-loaded; uses Leap arrays
    + **L-PBWT-Query** memory extensive, panel in memory; uses Leap arrays
  + computes external **L-long matches** 

+ syllable-PBWT [@wangSyllablePBWTSpaceefficientHaplotype2023] [git](https://github.com/ZhiGroup/Syllable-PBWT)
  + syllable-encoding of the PBWT, 64 or 128 bits
  + reads VCF
  + indexes and queries of patterns against Panel, parametrized by $B$ syllable length ($B=\{64, 128\}$) 
  + computes external **L-long matches** with $L \geq 2B$
  + notes: in the paper section (2.1) and Table 1, they write about "bit-PBWT" referring to the Durbin's original PBWT used in PBWT-Query [@naseriEfficientHaplotypeMatching2019] and d-PBWT [@sanaullahDPBWTDynamicPositional2021]


+ mc-PBWT: multi column (parallel?) scanning of the PBWT (double and triple) [@shakyaMcPBWTSpaceEfficientMulticolumn2022] used for "Matches of exact Lenght $L$
    
+ parallel PBWT (VCF/BCF): first version, vertically parallel + reconcile [@wertenbroekExploitingParallelizationPositional2023] Long Matches and SMEMs 

+ HB-parallel PBWT (VCF?): last version, horizontally parallel [@tangHaplotypebasedParallelPBWT2025] Long Matches and SMEMs

+ Trie-based Block Matching [@cunhaIdentifyingMaximalPerfect2018]

+ Haploblocks (PBWT-based block Matching) [@alankoFindingAllMaximal2020] [git](https://gitlab.com/bacazaux/haploblocks)

+ Bi-directional PBWT [@naseriEfficientHaplotypeBlock2021] [git](https://github.com/ZhiGroup/bi-PBWT)

+ WildHap (Trie-based \* block matching) [@williamsMaximalPerfectHaplotype2020] [git](williamsExtendingMaximalPerfect2020)

+ Wild-pBWT (PBWT-based \* block matching) [@bonizzoniMultiallelicMaximalPerfect2023] [git](https://github.com/AlgoLab/Wild-pBWT)

+ templated PBWT [@freymanFastRobustIdentitybyDescent2021] [git](https://github.com/23andMe/phasedibd)

+ psmoother [@yuePsmootherEfficientPBWT2022] [git](https://github.com/ZhiGroup/P-smoother)



- tree consistent pbwt (tc-pbwt)
- fast recomb
- Data Structures for SMEM-Finding in the PBWT
- Compressed Data Structures for Population-Scale Positional Burrowsâ€“Wheeler Transforms
- multiallelic pbwt (zing, zang, sanahulla)
- templated PBWT
- FiMap PBWT


 Compression
- Durbin
- CoMSA (gPBWT)
- GTShark


## References {.smaller}

::: {#refs}
:::
